<[autotemplate]
documentclass={beamer}
usecolortheme={default}

usepackage=[utf8]{inputenc}
usepackage=[T1]{fontenc}
usepackage={graphicx}

title={Git-Workshop}
subtitle={Chemnitzer Linuxtage 2010}
author={Valentin Hänel, Julius Plenz}
date={13. März 2010}
[autotemplate]>

==== Wer kennt wen? ====

Wer kennt oder hat schon mal eines der folgenden Systeme benutzt?
* CVS/RCS
* SVN
* Mercurial, Darcs, Perforce, Bazaar
* Git

==== Wer kennt Git? ====

Wer hat schonmal ...
* @git@ eingegeben
* Ein Git-Repository selbst erstellt?
* ... oder geklont?
* Einen Commit gemacht?
* Per Git mit anderen Leuten zusammengearbeitet?

== Erste Kommandos ==

==== Wer bin ich? -- Name und E-Mail einstellen ====

* Für alle Projekte (wird in @\~{}/.gitconfig@ gespeichert)
** @git config -{}-global user.name "Max Mustermann"@
** \texttt{git config -{}-global user.email max@mustermann.de}

* ... oder alternativ nur für das aktuelle Projekt:
** \texttt{git config user.email maintainer@cool-project.org}

* Außerdem, für die, die wollen: Farbe!
** @git config -{}-global color.ui auto@

==== Ein Projekt importieren oder erstellen ====

* Ein neues Projekt erstellt man wie folgt:
** @mkdir ''projekt''@
** @cd ''projekt''@
** @git init@

* Um ein bestehendes Projekt zu importieren, »klont« man es mit seiner gesamten Versionsgeschichte:
** \texttt{git clone git@git.plenz.com:\emph{git-workshop}}

==== Begriffsbildung ====

* '''Index'''/'''Staging Area''': Bereich zwischen dem Arbeitsverzeichnis und dem Repository, in die Änderungen für den nächsten '''Commit''' gesammelt werden
* '''Commit''': Eine Änderung an einer oder mehrerer Dateien, versehen mit Metadaten wie Autor, Datum und Beschreibung
* '''Referenz''': Jeder '''Commit''' wird durch eine eindeutige SHA1-Summe identifiziert. Eine Referenz »zeigt« auf einen bestimmten Commit
* '''Branch''': Ein »Zweig«, eine Abzweigung im Entwicklungszyklus, z.\,B. um ein neues Feature einzuführen.

==== Ein typischer Arbeitsablauf ====

* Eine @''datei''@ verändern, und die Änderungen in das Repository »einchecken«:
# @vim ''datei''@
# @git status@
# @git add ''datei''@
# @git commit -m '\emph{datei} angepasst'@
# @git show@

==== Informationen über das Repository erhalten ====

* Den jüngsten Commit im vollen Umfang anschauen:
** @git show@

* Die gesamte Versionsgeschichte, die zum aktuellen Zustand führt, anzeigen:
** @git log@

* Was hat sich verändert?
** @git diff@

* Das Repository visualisieren:
** @gitk@
* ... oder textbasiert:
** @tig@

==== Branches: Abzweigungen ====

Wir arbeiten schon die ganze Zeit im @master@-Branch!
--.5cm--

Branches ...
* erstellen: @git branch ''name''@
* auschecken: @git checkout ''name''@
* erstellen und direkt auschecken: @git checkout -b ''name''@
* auflisten: @git branch@
* löschen: @git branch -d ''name''@

--.5cm--
Was genau sind Branches? -- Nichts anderes als Referenzen auf den jeweils
obersten Commit einer Versionsgeschichte.

--.5cm--
Idealisierter Workflow: Ein Branch pro neuem Feature oder Bugfix.

==== Merging: Branches Zusammenfügen ====

Simple Merge:
* @git merge ''neues-feature''@

--.5cm--

Fast-Forward Merge:
* Wird @''topic''@ in @''master''@ gemerget und @''topic''@ basiert auf @''master''@, dann wird kein Merge-Commit erstellt, sondern nur der Zeiger »weitergerückt«. [TODO: Bessere Formulierung!]

==== Rebasing ====

* '''Rebase''': Einen Branch auf eine »neue Basis« stellen:
** @git rebase master ''topic''@

* Interaktiv Commits neu ordnen, bearbeiten, zusammenfassen oder aufteilen:
** @git rebase -i HEAD\~{}5@

* _red_'''Wichtig:'''_ Man darf '''''niemals''''' Commits aus einem bereits veröffentlichten Branch -- auf dem also womöglich Andere ihre Arbeit basieren -- durch @git rebase@ verändern!
** '''Daher: Nur Unveröffentlichtes gegen Veröffentlichtes rebasen:'''
*** @git rebase origin/master@
*** @git rebase v1.1.23@

==== Hilfe, Konflikte! ====

Bei @merge@ und @rebase@ kann es zu Konflikten kommen. Wie geht man damit um?
* @vim ''konfliktdateien''@
* @git add ''konfliktdateien''@
* @git commit -m "''Merge-Konflikt behoben''"@
* ggf. @git rebase -{}-continue@

Das Unterfangen abbrechen:
* @git reset HEAD@, oder
* @git rebase -{}-abort@

TODO: rerere erwähnen bzw. vorführen!

==== Hinaus in die weite Welt! ====

* Wir wollen unsere Arbeit mit der anderer Entwickler austauschen!
* Durch die verteilte Architektur von @git@ braucht es keinen ''zentralen'' Server zu geben.
* Das Entwicklerteam muss sich auf einen ''Workflow'' einigen:
** Shared Repository
** Maintainer/Blessed Repository
** Patch-Queue per E-Mail
** ... oder auch alles durcheinandergemixt.

==== Remote Repositories / Remote Branches ====

Remote Repositories:
* @git remote -v@
* @git remote add ''ws-ro'' git.plenz.com:git-workshop@
* @git remote update@

Remote Branches auflisten:
* @git branch -r@

Schauen, »wie weit vorne« die anderen sind:
* @git log ''ws-ro''/master..@

==== Fremden Code holen, eigenen versenden ====

Aus einem anderen Repository neuen Code »ziehen«:
* @git pull ''remote'' ''branch''@
** @git pull origin master@
Was hinter den Kulissen passiert:
# @git fetch ''remote'' ''branch''@
# @git merge ''remote''/''branch''@

--.5cm--
Eigene Commits »pushen« oder per E-Mail senden:
* @git push ''remote'' ''branch''@
* @git format-patch ''seit-wann''@

==== Kür: Was noch fehlt ====

* Remote Branches löschen
* @git stash@
* Git-Aliase
* Tags
* Reflog
